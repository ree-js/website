import NativeImport from "@reejs/imports/nativeImport.js";
let fs = await NativeImport("node:fs");
let path = await NativeImport("node:path");

let MODIFIED_FILES;
//check if .reejs/serve.cache exists
if (!fs.existsSync(path.join(".reejs", "copy.cache"))) {
  if(!fs.existsSync(".reejs")) fs.mkdirSync(".reejs");
  fs.writeFileSync(path.join(".reejs", "copy.cache"), "[]");
}

function copyFolderSync(source, target) {
  if (!fs.existsSync(target)) {
    fs.mkdirSync(target);
  }

  fs.readdirSync(source).forEach((file) => {
    const filePath = path.join(source, file);
    const targetPath = path.join(target, file);
    let stat = fs.statSync(filePath);
    if (stat.isFile()) {
      if (globalThis?.process?.env?.PSC_DISABLE != "true" && globalThis?.Deno?.env?.get("PSC_DISABLE") != "true") {
        // check if the file was modified, by comparing the mtime
        let mtime = stat.mtimeMs;
        let modified = MODIFIED_FILES.find((e) => e.f == filePath);
        if (modified && modified.at == mtime) {
          return;
        };
      }
      //add savedAt to MODIFIED_FILES array as {file: savedAt, at: mtime} where mtime is the mtime of the file
      MODIFIED_FILES.push({ f: filePath, at: stat.mtimeMs });
      //run fs async save MODIFIED_FILES as it should not block the main thread
      fs.writeFile(
        path.join(".reejs", "copy.cache"),
        JSON.stringify(MODIFIED_FILES),
        () => { });
      fs.copyFileSync(filePath, targetPath);
    } else {
      copyFolderSync(filePath, targetPath);
    }
  });
}

export default copyFolderSync;
